import chessimport re# SAN pattern parser definitions using regular expressionssan_pattern = re.compile(r"""    ^    (?P<piece>[KQRBN])?              # Optional piece    (?P<disambiguation>[a-h1-8]{0,2})# Optional disambiguation    (?P<capture>x)?                  # Optional capture    (?P<target>[a-h][1-8])           # Target square    (?P<promotion>=?[QRBN])?         # Optional promotion    (?P<check>[+#])?                 # Optional check or mate    $""", re.VERBOSE)# Function to describe moves in BNFdef describe_bnf(move_text):    if move_text in ["O-O", "O-O-O"]:        return f"<castle> ::= '{move_text}'"    match = san_pattern.match(move_text)    if not match:        return "Could not parse into BNF components."    parts = []    # Piece    piece = match.group("piece")    if piece:        parts.append(f"<piece> ::= '{piece}'")    else:        parts.append("<piece> ::= 'P'")  # Pawn by default    # Disambiguation    disambiguation = match.group("disambiguation")    if disambiguation:        parts.append(f"<disambiguation> ::= '{disambiguation}'")    # Capture    if match.group("capture"):        parts.append("<capture> ::= 'x'")    # Target square    target = match.group("target")    parts.append(f"<square> ::= '{target}'")    # Promotion    promotion = match.group("promotion")    if promotion:        promo = promotion.lstrip("=")        parts.append(f"<promotion> ::= '={promo}'")    # Check or mate    if match.group("check"):        parts.append(f"<check_or_mate> ::= '{match.group('check')}'")    return "\n".join(parts)# Initialize the gameboard = chess.Board()move_history = []print(board)while True:    user_move = input("\nEnter SAN move (or type 'exit' to quit): ").strip()    if user_move.lower() == "exit":        break    try:        move = board.parse_san(user_move)        board.push(move)        move_history.append(move)        print(board)        # Print BNF-style breakdown        print(describe_bnf(user_move))    except ValueError as e:        print(f"Invalid move, reason: {e}")# Print move history in a Binary Treeprint("\n Partida (Root)")for i in range(0, len(move_history), 2):    move_num = i // 2 + 1    white_move = move_history[i]    black_move = move_history[i + 1] if i + 1 < len(move_history) else"(waiting...)" # paceholder for black movement    print(f"Move {move_num}")    print(f"├── White: {white_move}")    print(f"└── Black: {black_move}")